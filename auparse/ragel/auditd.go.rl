// Code generated by ragel DO NOT EDIT.
package ragel

import (
    "encoding/hex"
    "fmt"
    "strconv"
)

%%{
machine auditd;

action mark {
    pb = p
}

action mark_header_end {
    msg_start = p
}

action set_msg {
    m.Message = string(data[msg_start:p])
}

action set_msgtype {
    m.Type = string(data[pb:p])
}

action set_timestamp {
    m.Timestamp = string(data[pb:p])
}

action set_seq_num {
    m.Sequence = string(data[pb:p])
}

action set_msg_id {
    if typeId, err := strconv.Atoi(string(data[pb:p])); err == nil {
        m.TypeID = int32(typeId)
    }
}

action set_key {
    key = string(data[pb:p])
    fmt.Println("KEY:", key)
}

action set_value_string {
    if value == "" {
        value = string(data[pb:p])
        fmt.Println("STRING:", value)
    }
}

action set_value_number {
    if value == "" {
        value = "NUM:" + string(data[pb:p])
        fmt.Println(value)
    }
}

action set_value_hex {
    if value == "" {
        value = "HEX:" + string(data[pb:p])
        fmt.Println(value)
        data, _ := hex.DecodeString(string(data[pb:p]))
        value = string(data)
        fmt.Println(value)
    }
}

action push_kv {
    if m.Values == nil {
        m.Values = map[string]string{}
    }
    if value != "" {
        m.Values[key] = value
        value = ""
    }
}

single_quote = "'";

double_quote = '"';

eq = '=';

hex = 'A' .. 'F' | '0' .. '9';

dash = '-';
underscore = '_';
colon = ':';
comma = ',';

double_quoted_value = (print-single_quote)* >mark %set_value_string;
single_quoted_value = (print-single_quote)* >mark %set_value_string;
number_value = (dash? digit{1,10}) >mark %set_value_number;
hex_value = (hex hex)+ >mark %set_value_hex;
string_value = (print - double_quote - single_quote - space)+ >mark %set_value_string;

single_quoted = single_quote single_quoted_value single_quote;
double_quoted = double_quote double_quoted_value double_quote;

value = (
    double_quoted %(num_vs_string, 3) |
    single_quoted %(num_vs_string, 3) |
    number_value  %(num_vs_string, 2) |
    hex_value     %(num_vs_string, 1) |
    string_value  %(num_vs_string, 0)
);

msg_type_chars = ( alpha | digit | "_");

key_name = alpha (alpha | digit | dash | underscore | space)+;

key = key_name >mark %set_key;

# Value may be empty. (Maybe want to use zlen with a *string to keep empty values.)
key_value = key "=" value? %push_kv;

msg_id = digit{4} >mark %set_msg_id;

msg_type = msg_type_chars+ >mark %set_msgtype;

unknown_msg_type = "UNKNOWN[" msg_id "]";

time_fractional = (digit+ "." digit{3}) >mark %set_timestamp;

seq_num = digit+ >mark %set_seq_num;

audit_header = "msg=audit(" time_fractional ":" seq_num "):" space %mark_header_end;

kv_pair_separator = space+ | (space colon space) | (comma space) | ( space '(' );
kvs = ((key_value kv_pair_separator+)* key_value) >set_msg;

msg = (print - eq )*;

main := "type=" (unknown_msg_type | msg_type) " " audit_header (msg space)? kvs;
inner_kvs := ((print - eq)+)? space? kvs >set_msg;
value_exp := value;

}%%

%% write data noerror noprefix;

type machineType int

const (
    AuditdMessage machineType = iota
    KeyValuePairs
    Value
)

func (mt machineType) toState() int {
    switch mt {
    case AuditdMessage:
        return en_main
    case KeyValuePairs:
        return en_inner_kvs
    case Value:
        return en_value_exp
    default:
        panic("unhanded type")
    }
}

// unpack unpacks an auditd message.
func (m *Message) unpack(data string) error {
    if err := m.unpackData(data, AuditdMessage); err != nil {
        return err
    }
    if m.Values == nil {
        return nil
    }
    if msg, found := m.Values["msg"]; found {
        if err := m.unpackData(msg, KeyValuePairs); err != nil {
            return fmt.Errorf("error parsing user msg %q: %w", msg, err)
        }
        delete(m.Values, "msg")
    }
    return nil
}

func (m *Message) unpackData(data string, machine machineType) error {
    p := 0
    pb := 0
    pe := len(data)
    eof := len(data)
    cs := machine.toState()

    msg_start := 0
    var key, value string
    %% write exec;

    if cs < first_final {
        return fmt.Errorf("error parsing message at pos %d", p+1)
    }
    return nil
}
