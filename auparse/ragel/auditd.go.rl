// Code generated by ragel DO NOT EDIT.
package ragel

import (
    "fmt"
    "strconv"
)

%%{
machine auditd;

action mark {
    pb = p
}

action mark_header_end {
    msg_start = p
}

action set_msg {
    m.Message = string(data[msg_start:p])
}

action set_msgtype {
    m.Type = string(data[pb:p])
}

action set_timestamp {
    m.Timestamp = string(data[pb:p])
}

action set_seq_num {
    m.Sequence = string(data[pb:p])
}

action set_msg_id {
    if typeId, err := strconv.Atoi(string(data[pb:p])); err == nil {
        m.TypeID = int32(typeId)
    }
}

action set_key {
    key = string(data[pb:p])
}

action set_value {
    value = string(data[pb:p])
}

action push_kv {
    if m.Values == nil {
        m.Values = map[string]string{}
    }
    if value != "" {
        m.Values[key] = value
        value = ""
    }
}

single_quote = "'";

double_quote = '"';

eq = '=';

hex = 'A' .. 'F' | '0' .. '9';

dash = '-';
underscore = '_';
colon = ':';
comma = ',';

non_quoted_value = (print - double_quote - single_quote - space)+  >mark %set_value;
single_quoted_value = (print-single_quote)* >mark %set_value;
single_quoted = single_quote single_quoted_value single_quote;
double_quoted_value = (print-single_quote)* >mark %set_value;
double_quoted = double_quote double_quoted_value double_quote;
value = non_quoted_value | single_quoted | double_quoted;

msg_type_chars = ( alpha | digit | "_");

key_name = alpha (alpha | digit | dash | underscore | space)+;

key = key_name >mark %set_key;

# Value may be empty.
key_value = key "=" value? %push_kv;

msg_id = digit{4} >mark %set_msg_id;

msg_type = msg_type_chars+ >mark %set_msgtype;

unknown_msg_type = "UNKNOWN[" msg_id "]";

time_fractional = (digit+ "." digit{3}) >mark %set_timestamp;

seq_num = digit+ >mark %set_seq_num;

audit_header = "msg=audit(" time_fractional ":" seq_num "):" space %mark_header_end;

kv_pair_separator = space+ | (space colon space) | (comma space) | ( space '(' );
kvs = ((key_value kv_pair_separator+)* key_value) >set_msg;

msg = (print - eq )*;

main := "type=" (unknown_msg_type | msg_type) " " audit_header (msg space)? kvs;
inner_kvs := ((print - eq)+)? space? kvs >set_msg;

}%%

%% write data noerror noprefix;

// unpack unpacks an auditd message.
func (m *Message) unpack(data string) error {
    if err := m.unpackData(data, en_main); err != nil {
        return err
    }
    if m.Values == nil {
        return nil
    }
    if msg, found := m.Values["msg"]; found {
        if err := m.unpackData(msg, en_inner_kvs); err != nil {
            return fmt.Errorf("error parsing user msg %q: %w", msg, err)
        }
        delete(m.Values, "msg")
    }
    return nil
}

func (m *Message) unpackData(data string, machine int) error {
    p := 0
    pb := 0
    pe := len(data)
    eof := len(data)
    cs := machine

    msg_start := 0
    var key, value string
    %% write exec;

    if cs < first_final {
        return fmt.Errorf("error parsing message at pos %d", p+1)
    }
    return nil
}
