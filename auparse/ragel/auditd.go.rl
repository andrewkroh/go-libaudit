// Code generated by ragel DO NOT EDIT.
package ragel

import (
    "fmt"
    "strconv"
)

%%{
machine auditd;

action mark {
    pb = p
}

action mark_header_end {
    auditHeaderEnd = p
}

action set_msg {
    m.Message = string(data[auditHeaderEnd:p])
}

action set_msgtype {
    m.Type = string(data[pb:p])
}

action set_timestamp {
    m.Timestamp = string(data[pb:p])
}

action set_seq_num {
    m.Sequence = string(data[pb:p])
}

action set_msg_id {
    if typeId, err := strconv.Atoi(string(data[pb:p])); err == nil {
        m.TypeID = int32(typeId)
    }
}

action set_key {
    key = string(data[pb:p])
}

action set_value_empty {
    if !hasValue {
        value = ""
    }
}

action set_value_string {
    if !hasValue {
        value = string(data[pb:p])
    }
}

action set_value_number {
    if !hasValue {
        value = string(data[pb:p])
    }
}

action set_value_hex {
    if !hasValue {
        value = string(data[pb:p])
    }
}

action push_kv {
    if m.Values == nil {
        m.Values = make(map[string]string, 10)
    }
    m.Values[key] = value
    value = ""
}

single_quote = "'";
double_quote = '"';
eq = '=';
upper_hex = 'A' .. 'F' | '0' .. '9';
dash = '-';
underscore = '_';
colon = ':';
comma = ',';
dot = '.';
open_bracket = '[';
close_bracket = ']';
open_paren = '(';
close_paren = ')';

#
# Audit Message Type
# Example: type=SYSCALL
#

# Example: UNKNOWN[1333]
msg_id = digit{4} >mark %set_msg_id;
unknown_audit_msg_type = "UNKNOWN" open_bracket msg_id close_bracket;

# Example: USER_CMD
known_audit_msg_type = (upper (upper | underscore)+)  >mark %set_msgtype;

audit_msg_type = "type=" (known_audit_msg_type | unknown_audit_msg_type);

#
# Audit Header
# Example: msg=audit(1491924063.550:1065565):
# The format is msg=audit(timestamp:ID) where timestamp is fractional unix epoch
# seconds containing millisecond precision.
#

time_fractional_sec = (digit+ dot digit{3}) >mark %set_timestamp;
seq_num = digit+ >mark %set_seq_num;
audit_header = "msg=audit" open_paren time_fractional_sec colon seq_num close_paren colon space %mark_header_end;

#
# Message
#
msg = (print)* %set_msg;

#
# Key Value Pairs
#

# Key
#
# Examples: pid, old auid, a3, new-level, denied_mask
key = (lower (lower | digit | dash | underscore | space)+) >mark %set_key;

# Value
#
# Examples:
#   number: -10, 6102
#   hex encoded: 2F7573722F6C6962
#   single quoted: 'foo="bar"'
#   double quoted: "/sbin/auditctl"
#   string: NORMAL
double_quoted_value = (print-double_quote)* >mark %set_value_string;
single_quoted_value = (print-single_quote)* >mark %set_value_string;
number_value = (dash? digit{1,10}) >mark %set_value_number;
hex_value = (upper_hex{2})+ >mark %set_value_hex;
string_value = (print - double_quote - single_quote - space)+ >mark %set_value_string;
empty_value = zlen %set_value_empty;

single_quoted = single_quote single_quoted_value single_quote;
double_quoted = double_quote double_quoted_value double_quote;

value = (
    empty_value |
    double_quoted |
    single_quoted |
    number_value  %(num_vs_string, 2) |
    hex_value     %(num_vs_string, 1) |
    string_value  %(num_vs_string, 0)
);

key_value = key "=" value %push_kv;

kv_pair_separator = space+ | (space colon space) | (comma space) | ( space '(' );
kv_pairs = ((key_value kv_pair_separator+)* key_value);

#
# Audit Message
# The type=MSG_TYPE is optional because netlink message from the kernel do
# not contain this part.
#
audit_msg = (audit_msg_type space)? audit_header (msg space)? :>> kv_pairs;

main := audit_msg;
user_msg_field := (msg space)? :>> kv_pairs;
field_value := value;

}%%

%% write data noerror noprefix;

type machineType int

const (
    AuditdMessage machineType = iota
    UserMsg
    FieldValue
)

func (mt machineType) toState() int {
    switch mt {
    case AuditdMessage:
        return en_main
    case UserMsg:
        return en_user_msg_field
    case FieldValue:
        return en_field_value
    default:
        panic("unhanded type")
    }
}

// unpack unpacks an auditd message.
func (m *Message) unpack(data string) error {
    if err := unpack(data, AuditdMessage, m); err != nil {
        return err
    }
    if m.Values == nil {
        return nil
    }
    if msg, found := m.Values["msg"]; found {
        if err := unpack(msg, UserMsg, m); err != nil {
            return fmt.Errorf("error parsing user msg %q: %w", msg, err)
        }
        delete(m.Values, "msg")
    }
    return nil
}

func unpack(data string, machine machineType, m *Message) error {
    p := 0
    pb := 0
    pe := len(data)
    eof := len(data)
    cs := machine.toState()

    var (
        auditHeaderEnd int
        key string
        value string
        hasValue bool
    )

    %% write init nocs;
    %% write exec;

    if cs < first_final {
        return fmt.Errorf("error parsing message at pos %d", p+1)
    }
    return nil
}

func stringValue(in string) *string { return &in }