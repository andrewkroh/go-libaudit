package rule_test

import (
	"fmt"
	"io/ioutil"
	"path/filepath"
	"testing"

	"github.com/elastic/go-libaudit/rule"
	"github.com/elastic/go-libaudit/rule/flags"

	"github.com/stretchr/testify/assert"
	"gopkg.in/yaml.v2"
)

type GoldenData struct {
	Rules []TestCase `yaml:"rules"`
}

type TestCase struct {
	Flags string `yaml:"flags"`
	Bytes string `yaml:"bytes"`
}

// TestBuild compares the WireFormat (binary data) generated by this package
// against known golden data generated on Linux with auditctl.
func TestBuildGolden(t *testing.T) {
	goldenFiles, err := filepath.Glob("testdata/*.rules.golden.yml")
	if err != nil {
		t.Fatal(err)
	}

	for _, goldenFile := range goldenFiles {
		testRulesFromGoldenFile(t, goldenFile)
	}
}

func testRulesFromGoldenFile(t *testing.T, goldenFile string) {
	t.Run(filepath.Base(goldenFile), func(t *testing.T) {
		testdata, err := ioutil.ReadFile(goldenFile)
		if err != nil {
			t.Fatal(err)
		}

		var tests GoldenData
		if err := yaml.Unmarshal(testdata, &tests); err != nil {
			t.Fatal(err)
		}

		for i, test := range tests.Rules {
			t.Run(fmt.Sprintf("rule %d", i), func(t *testing.T) {
				if testing.Verbose() {
					t.Log("rule:", test.Flags)
				}

				r, err := flags.Parse(test.Flags)
				if err != nil {
					t.Fatal("rule:", test.Flags, "error:", err)
				}

				actualBytes, err := rule.Build(r)
				if err != nil {
					t.Fatal("rule:", test.Flags, "error:", err)
				}

				//fmt.Println(hex.Dump([]byte(actualBytes)))
				assert.EqualValues(t, []byte(test.Bytes), []byte(actualBytes), "rule: %v", test.Flags)
			})
		}
	})
}
